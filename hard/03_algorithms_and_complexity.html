
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Hard Lesson 03: Algorithms and Complexity Analysis &#8212; Education Playground</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=d342674e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=c73c0f3e"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'hard/03_algorithms_and_complexity';</script>
    <script src="../_static/js/mobile-nav.js?v=66ebaa39"></script>
    <script src="../_static/js/onboarding.js?v=e068e0de"></script>
    <link rel="canonical" href="https://mykolas-perevicius.github.io/Education_Playground/hard/03_algorithms_and_complexity.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Lesson 4: Deep Learning and Neural Networks" href="04_deep_learning_and_neural_networks.html" />
    <link rel="prev" title="Hard Lesson 02: Generators and Iterators - Memory-Efficient Data Processing" href="02_generators_and_iterators.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../README.html">
  
  
  
  
  
  
    <p class="title logo__title">Education Playground</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../00_calibration_test.html">üéØ Calibration Test - Find Your Level</a></li>
<li class="toctree-l1"><a class="reference internal" href="../beginner_scripts/README.html">üå± Beginner Scripts (10 Python Files)</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../easy/README_EASY.html">üìó Easy Level - Beginner</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../easy/01_introduction_to_python.html">1. Introduction to Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../easy/02_variables_and_data_types.html">2. Variables and Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../easy/03_basic_operations_and_conditionals.html">3. Operations and Conditionals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../easy/04_intro_to_ai_and_ml.html">4. Intro to AI and ML</a></li>
<li class="toctree-l2"><a class="reference internal" href="../easy/05_computing_fundamentals.html">5. Computing Fundamentals</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../medium/README_MEDIUM.html">üìò Medium Level - Intermediate</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../medium/01_functions_and_modules.html">1. Functions and Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../medium/02_data_structures.html">2. Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../medium/03_classes_and_oop.html">3. Classes and OOP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../medium/04_machine_learning_basics.html">4. Machine Learning Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../medium/05_data_analysis_with_pandas.html">5. Data Analysis with Pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../medium/06_algorithms_and_problem_solving.html">6. Algorithms and Problem Solving</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="README_HARD.html">üìï Hard Level - Advanced</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="01_advanced_functions_and_decorators.html">1. Advanced Functions &amp; Decorators</a></li>
<li class="toctree-l2"><a class="reference internal" href="02_generators_and_iterators.html">2. Generators and Iterators</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">3. Algorithms and Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="04_deep_learning_and_neural_networks.html">4. Deep Learning &amp; Neural Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="05_advanced_ml_and_nlp.html">5. Advanced ML and NLP</a></li>
<li class="toctree-l2"><a class="reference internal" href="06_computer_systems_and_theory.html">6. Computer Systems and Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="07_project_ideas.html">7. Project Ideas &amp; Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="08_classic_problems.html">Lesson 8: Classic Problems Collection</a></li>





<li class="toctree-l2"><a class="reference internal" href="09_ctf_challenges.html">Lesson 9: Capture The Flag (CTF) - Hacker Training</a></li>






<li class="toctree-l2"><a class="reference internal" href="10_performance_computing.html">10. Performance Computing ‚ö° NEW!</a></li>
<li class="toctree-l2"><a class="reference internal" href="11_cuda_and_parallel_computing.html">11. CUDA &amp; GPU Computing üéÆ NEW!</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../tools/README.html">üõ†Ô∏è Developer Tools Track</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../tools/01_shell_basics.html">1. Shell and Command Line</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/02_command_line_tools.html">2. Command Line Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/03_git_essentials.html">3. Git Essentials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/04_text_editors.html">4. Text Editors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/05_build_systems_cicd.html">5. Build Systems and CI/CD</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/06_debugging_profiling.html">6. Debugging and Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/07_security_essentials.html">7. Security Essentials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/08_package_management.html">8. Package Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/09_ssh_remote_systems.html">9. SSH and Remote Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/10_docker_containers.html">10. Docker and Containers</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../solutions/README_SOLUTIONS.html">üìù Solutions</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../solutions/easy_solutions.html">Easy Level - Complete Solutions</a></li>





<li class="toctree-l2"><a class="reference internal" href="../solutions/medium_solutions.html">Medium Level - Complete Solutions</a></li>






<li class="toctree-l2"><a class="reference internal" href="../solutions/hard_solutions.html">Hard Level - Complete Solutions</a></li>








<li class="toctree-l2"><a class="reference internal" href="../solutions/tools_solutions.html">Developer Tools - Complete Solutions</a></li>






</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../RESOURCES.html">üìö Learning Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PYTHON_CHEATSHEET.html">‚ö° Python Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ML_AI_CHEATSHEET.html">ü§ñ ML/AI Cheat Sheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SETUP.html">üîß Setup Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE_NOTES_v2.0.0.html">üéâ Release Notes v2.0.0</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none"></div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Hard Lesson 03: Algorithms and Complexity Analysis</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#learning-objectives">Learning Objectives</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#prerequisites">Prerequisites</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#why-algorithms-and-complexity-matter">Why Algorithms and Complexity Matter</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-1-big-o-notation-the-language-of-complexity">Part 1: Big O Notation - The Language of Complexity</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#what-is-big-o">What is Big O?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#common-complexity-classes-best-to-worst">Common Complexity Classes (Best to Worst)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analyzing-code-for-complexity">Analyzing Code for Complexity</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-2-sorting-algorithms-comparison-and-implementation">Part 2: Sorting Algorithms - Comparison and Implementation</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#elementary-sorting-algorithms-o-n2">Elementary Sorting Algorithms (O(n¬≤))</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#advanced-sorting-algorithms-o-n-log-n">Advanced Sorting Algorithms (O(n log n))</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sorting-algorithm-comparison">Sorting Algorithm Comparison</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-3-searching-algorithms">Part 3: Searching Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-search-the-o-log-n-workhorse">Binary Search - The O(log n) Workhorse</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-4-recursion-divide-and-conquer">Part 4: Recursion - Divide and Conquer</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#understanding-recursion">Understanding Recursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-5-dynamic-programming-optimization-through-memoization">Part 5: Dynamic Programming - Optimization Through Memoization</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#memoization-top-down">Memoization (Top-Down)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tabulation-bottom-up">Tabulation (Bottom-Up)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classic-dp-problems">Classic DP Problems</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-6-graph-algorithms">Part 6: Graph Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-representation-and-traversal">Graph Representation and Traversal</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-7-space-complexity">Part 7: Space Complexity</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-1-implement-and-analyze-quick-select">Exercise 1: Implement and Analyze Quick Select</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-2-longest-increasing-subsequence">Exercise 2: Longest Increasing Subsequence</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-3-detect-cycle-in-graph">Exercise 3: Detect Cycle in Graph</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-4-implement-a-pathfinding">Exercise 4: Implement A* Pathfinding</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pro-tips">Pro Tips</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithm-selection-guide">üéØ Algorithm Selection Guide</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#common-mistakes">‚ö†Ô∏è Common Mistakes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#optimization-strategies">üí° Optimization Strategies</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#key-takeaways">Key Takeaways</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-steps">Next Steps</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="hard-lesson-03-algorithms-and-complexity-analysis">
<h1>Hard Lesson 03: Algorithms and Complexity Analysis<a class="headerlink" href="#hard-lesson-03-algorithms-and-complexity-analysis" title="Link to this heading">#</a></h1>
<p>Master algorithm design, complexity analysis, and efficient problem-solving techniques.</p>
<section id="learning-objectives">
<h2>Learning Objectives<a class="headerlink" href="#learning-objectives" title="Link to this heading">#</a></h2>
<p>By the end of this lesson, you will be able to:</p>
<ul class="simple">
<li><p>‚úÖ Analyze time and space complexity using Big O notation</p></li>
<li><p>‚úÖ Understand and apply all major complexity classes (O(1), O(log n), O(n), O(n log n), O(n¬≤), O(2‚Åø))</p></li>
<li><p>‚úÖ Implement and compare sorting algorithms (bubble, selection, insertion, merge, quick, heap)</p></li>
<li><p>‚úÖ Apply searching algorithms (linear, binary, interpolation)</p></li>
<li><p>‚úÖ Design recursive solutions with proper base cases</p></li>
<li><p>‚úÖ Solve problems using dynamic programming (memoization and tabulation)</p></li>
<li><p>‚úÖ Apply greedy algorithms for optimization problems</p></li>
<li><p>‚úÖ Implement graph algorithms (DFS, BFS, Dijkstra‚Äôs, topological sort)</p></li>
<li><p>‚úÖ Choose the right algorithm for specific problems</p></li>
</ul>
</section>
<section id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Strong understanding of Python data structures (lists, dicts, sets)</p></li>
<li><p>Familiarity with recursion</p></li>
<li><p>Basic understanding of graphs and trees</p></li>
<li><p>Knowledge of object-oriented programming</p></li>
</ul>
</section>
<section id="why-algorithms-and-complexity-matter">
<h2>Why Algorithms and Complexity Matter<a class="headerlink" href="#why-algorithms-and-complexity-matter" title="Link to this heading">#</a></h2>
<p><strong>Real-World Impact</strong>:</p>
<ul class="simple">
<li><p><strong>Google Search</strong>: Returns results in milliseconds from trillions of pages (efficient algorithms)</p></li>
<li><p><strong>Netflix Recommendations</strong>: Processes billions of data points (optimized complexity)</p></li>
<li><p><strong>GPS Navigation</strong>: Finds shortest path in real-time (Dijkstra‚Äôs algorithm)</p></li>
<li><p><strong>Database Indexing</strong>: Fast queries on massive datasets (B-trees, O(log n) search)</p></li>
<li><p><strong>Compiler Optimization</strong>: Efficient code generation (graph algorithms)</p></li>
<li><p><strong>Machine Learning</strong>: Training on huge datasets (efficient matrix operations)</p></li>
</ul>
<p><strong>Cost Implications</strong>:</p>
<ul class="simple">
<li><p>O(n¬≤) vs O(n log n): At 1 million items, could mean hours vs seconds</p></li>
<li><p>Poor algorithm choice can cost millions in cloud computing</p></li>
<li><p>Efficient algorithms enable real-time systems</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="part-1-big-o-notation-the-language-of-complexity">
<h2>Part 1: Big O Notation - The Language of Complexity<a class="headerlink" href="#part-1-big-o-notation-the-language-of-complexity" title="Link to this heading">#</a></h2>
<section id="what-is-big-o">
<h3>What is Big O?<a class="headerlink" href="#what-is-big-o" title="Link to this heading">#</a></h3>
<p>Big O notation describes how algorithm performance scales with input size.</p>
<p><strong>Key Principles</strong>:</p>
<ul class="simple">
<li><p><strong>Drop constants</strong>: O(2n) ‚Üí O(n), O(100) ‚Üí O(1)</p></li>
<li><p><strong>Drop lower-order terms</strong>: O(n¬≤ + n) ‚Üí O(n¬≤)</p></li>
<li><p><strong>Focus on worst case</strong>: What happens when input is largest/worst?</p></li>
<li><p><strong>Ignore coefficients</strong>: O(3n log n) ‚Üí O(n log n)</p></li>
</ul>
</section>
<section id="common-complexity-classes-best-to-worst">
<h3>Common Complexity Classes (Best to Worst)<a class="headerlink" href="#common-complexity-classes-best-to-worst" title="Link to this heading">#</a></h3>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Complexity</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Example</p></th>
<th class="head"><p>1K items</p></th>
<th class="head"><p>1M items</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>O(1)</strong></p></td>
<td><p>Constant</p></td>
<td><p>Array access</p></td>
<td><p>1 op</p></td>
<td><p>1 op</p></td>
</tr>
<tr class="row-odd"><td><p><strong>O(log n)</strong></p></td>
<td><p>Logarithmic</p></td>
<td><p>Binary search</p></td>
<td><p>~10 ops</p></td>
<td><p>~20 ops</p></td>
</tr>
<tr class="row-even"><td><p><strong>O(n)</strong></p></td>
<td><p>Linear</p></td>
<td><p>Linear search</p></td>
<td><p>1K ops</p></td>
<td><p>1M ops</p></td>
</tr>
<tr class="row-odd"><td><p><strong>O(n log n)</strong></p></td>
<td><p>Linearithmic</p></td>
<td><p>Merge sort</p></td>
<td><p>~10K ops</p></td>
<td><p>~20M ops</p></td>
</tr>
<tr class="row-even"><td><p><strong>O(n¬≤)</strong></p></td>
<td><p>Quadratic</p></td>
<td><p>Bubble sort</p></td>
<td><p>1M ops</p></td>
<td><p>1T ops</p></td>
</tr>
<tr class="row-odd"><td><p><strong>O(2‚Åø)</strong></p></td>
<td><p>Exponential</p></td>
<td><p>Recursive Fibonacci</p></td>
<td><p>Insane</p></td>
<td><p>Impossible</p></td>
</tr>
<tr class="row-even"><td><p><strong>O(n!)</strong></p></td>
<td><p>Factorial</p></td>
<td><p>Traveling salesman</p></td>
<td><p>Death</p></td>
<td><p>Heat death of universe</p></td>
</tr>
</tbody>
</table>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">measure_time</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utility to measure execution time.&quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">elapsed</span>

<span class="c1"># O(1) - Constant Time</span>
<span class="c1"># Operations that take same time regardless of input size</span>
<span class="k">def</span> <span class="nf">get_first_element</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;O(1) - Array access is constant time.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">arr</span> <span class="k">else</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">hash_lookup</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;O(1) average case - Hash table lookup.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="c1"># O(log n) - Logarithmic Time</span>
<span class="c1"># Halves problem size each iteration</span>
<span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;O(log n) - Binary search on sorted array.&quot;&quot;&quot;</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">elif</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># O(n) - Linear Time</span>
<span class="c1"># Processes each element once</span>
<span class="k">def</span> <span class="nf">linear_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;O(n) - Must check each element.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">find_max</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;O(n) - Must examine all elements.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">max_val</span><span class="p">:</span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">max_val</span>

<span class="c1"># O(n¬≤) - Quadratic Time</span>
<span class="c1"># Nested loops over same data</span>
<span class="k">def</span> <span class="nf">find_duplicates</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;O(n¬≤) - Nested loop comparing all pairs.&quot;&quot;&quot;</span>
    <span class="n">duplicates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">duplicates</span><span class="p">:</span>
                <span class="n">duplicates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">duplicates</span>

<span class="c1"># Test complexity differences</span>
<span class="n">test_arr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">))</span>  <span class="c1"># Sorted array</span>

<span class="n">_</span><span class="p">,</span> <span class="n">t_const</span> <span class="o">=</span> <span class="n">measure_time</span><span class="p">(</span><span class="n">get_first_element</span><span class="p">,</span> <span class="n">test_arr</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">t_log</span> <span class="o">=</span> <span class="n">measure_time</span><span class="p">(</span><span class="n">binary_search</span><span class="p">,</span> <span class="n">test_arr</span><span class="p">,</span> <span class="mi">9999</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">t_linear</span> <span class="o">=</span> <span class="n">measure_time</span><span class="p">(</span><span class="n">linear_search</span><span class="p">,</span> <span class="n">test_arr</span><span class="p">,</span> <span class="mi">9999</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Complexity Comparison (10,000 elements):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  O(1)     - Constant:     </span><span class="si">{</span><span class="n">t_const</span><span class="o">*</span><span class="mi">1000</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  O(log n) - Logarithmic:  </span><span class="si">{</span><span class="n">t_log</span><span class="o">*</span><span class="mi">1000</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  O(n)     - Linear:       </span><span class="si">{</span><span class="n">t_linear</span><span class="o">*</span><span class="mi">1000</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">O(log n) is </span><span class="si">{</span><span class="n">t_linear</span><span class="o">/</span><span class="n">t_log</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">x faster than O(n) for this size!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="analyzing-code-for-complexity">
<h3>Analyzing Code for Complexity<a class="headerlink" href="#analyzing-code-for-complexity" title="Link to this heading">#</a></h3>
<p><strong>Rules of thumb</strong>:</p>
<ol class="arabic simple">
<li><p><strong>Simple statements</strong>: O(1)</p></li>
<li><p><strong>Single loop</strong>: O(n) where n is loop iterations</p></li>
<li><p><strong>Nested loops</strong>: Multiply complexities (usually O(n¬≤))</p></li>
<li><p><strong>Divide and conquer</strong>: Often O(log n) or O(n log n)</p></li>
<li><p><strong>Sequential statements</strong>: Add complexities, keep dominant term</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">analyze_complexity_examples</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Demonstrate complexity analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="c1"># Example 1: O(1) + O(n) = O(n)</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># O(1)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>   <span class="c1"># O(n)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Overall: O(n) - keep dominant term</span>
    
    <span class="c1"># Example 2: O(n) + O(n) = O(n)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>   <span class="c1"># O(n)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>   <span class="c1"># O(n)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Overall: O(2n) = O(n) - drop constants</span>
    
    <span class="c1"># Example 3: O(n) * O(n) = O(n¬≤)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>   <span class="c1"># O(n)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>  <span class="c1"># O(n) for each i</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="c1"># Overall: O(n¬≤) - nested loops multiply</span>
    
    <span class="c1"># Example 4: O(n¬≤) + O(n) = O(n¬≤)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>      <span class="c1"># O(n¬≤)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>      <span class="c1"># O(n)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Overall: O(n¬≤) - keep dominant term</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Complexity Analysis Rules:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  1. Drop constants: O(2n) ‚Üí O(n)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  2. Drop lower terms: O(n¬≤ + n) ‚Üí O(n¬≤)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  3. Sequential: Add, keep dominant&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  4. Nested loops: Multiply&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  5. Divide input: Often O(log n)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="part-2-sorting-algorithms-comparison-and-implementation">
<h2>Part 2: Sorting Algorithms - Comparison and Implementation<a class="headerlink" href="#part-2-sorting-algorithms-comparison-and-implementation" title="Link to this heading">#</a></h2>
<section id="elementary-sorting-algorithms-o-n2">
<h3>Elementary Sorting Algorithms (O(n¬≤))<a class="headerlink" href="#elementary-sorting-algorithms-o-n2" title="Link to this heading">#</a></h3>
<p>Good for small datasets or nearly sorted data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bubble Sort - O(n¬≤) time, O(1) space</span>
<span class="sd">    </span>
<span class="sd">    Repeatedly swaps adjacent elements if they&#39;re in wrong order.</span>
<span class="sd">    Largest element &quot;bubbles&quot; to end each pass.</span>
<span class="sd">    </span>
<span class="sd">    Pros: Simple, stable, in-place</span>
<span class="sd">    Cons: Slow for large data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Last i elements are already sorted</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">swapped</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="c1"># Optimization: stop if no swaps (already sorted)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">swapped</span><span class="p">:</span>
            <span class="k">break</span>
    
    <span class="k">return</span> <span class="n">arr</span>

<span class="k">def</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selection Sort - O(n¬≤) time, O(1) space</span>
<span class="sd">    </span>
<span class="sd">    Finds minimum element and swaps to beginning.</span>
<span class="sd">    </span>
<span class="sd">    Pros: Simple, fewer swaps than bubble</span>
<span class="sd">    Cons: Not stable, always O(n¬≤)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># Find minimum in remaining unsorted portion</span>
        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]:</span>
                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">j</span>
        
        <span class="c1"># Swap minimum to current position</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_idx</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">arr</span>

<span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insertion Sort - O(n¬≤) worst case, O(n) best case, O(1) space</span>
<span class="sd">    </span>
<span class="sd">    Builds sorted array one element at a time.</span>
<span class="sd">    Like sorting playing cards in your hand.</span>
<span class="sd">    </span>
<span class="sd">    Pros: Stable, efficient for small/nearly sorted data, online algorithm</span>
<span class="sd">    Cons: O(n¬≤) for large random data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        
        <span class="c1"># Shift elements greater than key to the right</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        
        <span class="c1"># Insert key at correct position</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
    
    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># Test elementary sorting</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="n">test_data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">90</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Elementary Sorting Algorithms:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Original:       </span><span class="si">{</span><span class="n">test_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Bubble Sort:    </span><span class="si">{</span><span class="n">bubble_sort</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Selection Sort: </span><span class="si">{</span><span class="n">selection_sort</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Insertion Sort: </span><span class="si">{</span><span class="n">insertion_sort</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="advanced-sorting-algorithms-o-n-log-n">
<h3>Advanced Sorting Algorithms (O(n log n))<a class="headerlink" href="#advanced-sorting-algorithms-o-n-log-n" title="Link to this heading">#</a></h3>
<p>Efficient for large datasets.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge Sort - O(n log n) time, O(n) space</span>
<span class="sd">    </span>
<span class="sd">    Divide and conquer:</span>
<span class="sd">    1. Divide array into halves</span>
<span class="sd">    2. Recursively sort each half</span>
<span class="sd">    3. Merge sorted halves</span>
<span class="sd">    </span>
<span class="sd">    Pros: Stable, guaranteed O(n log n), good for linked lists</span>
<span class="sd">    Cons: O(n) extra space, not in-place</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    
    <span class="c1"># Divide</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>
    
    <span class="c1"># Conquer (merge)</span>
    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge two sorted arrays.&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Compare and merge</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># Append remaining elements</span>
    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quick Sort - O(n log n) average, O(n¬≤) worst case, O(log n) space</span>
<span class="sd">    </span>
<span class="sd">    Divide and conquer:</span>
<span class="sd">    1. Choose pivot</span>
<span class="sd">    2. Partition: elements &lt; pivot left, &gt; pivot right</span>
<span class="sd">    3. Recursively sort partitions</span>
<span class="sd">    </span>
<span class="sd">    Pros: Fast in practice, in-place (with optimization), cache-friendly</span>
<span class="sd">    Cons: Not stable, worst case O(n¬≤) with bad pivots</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    
    <span class="c1"># Choose pivot (middle element)</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    
    <span class="c1"># Partition</span>
    <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>
    
    <span class="c1"># Recursively sort and combine</span>
    <span class="k">return</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">middle</span> <span class="o">+</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">heapsort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Heap Sort - O(n log n) time, O(1) space</span>
<span class="sd">    </span>
<span class="sd">    1. Build max heap from array</span>
<span class="sd">    2. Repeatedly extract maximum</span>
<span class="sd">    </span>
<span class="sd">    Pros: In-place, guaranteed O(n log n)</span>
<span class="sd">    Cons: Not stable, slower than quicksort in practice</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maintain max heap property.&quot;&quot;&quot;</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span>
        
        <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>
    
    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="c1"># Build max heap</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    
    <span class="c1"># Extract elements from heap</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">arr</span>

<span class="c1"># Benchmark sorting algorithms</span>
<span class="n">test_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Sorting Algorithm Performance (random data):</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Algorithm&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;n=100&#39;</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;n=1000&#39;</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;n=5000&#39;</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">55</span><span class="p">)</span>

<span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">test_sizes</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">:</span>  <span class="c1"># Only test O(n¬≤) on small data</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">measure_time</span><span class="p">(</span><span class="n">bubble_sort</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Bubble Sort&#39;</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">t</span><span class="o">*</span><span class="mi">1000</span><span class="si">:</span><span class="s2">&gt;10.4f</span><span class="si">}</span><span class="s2">ms&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">measure_time</span><span class="p">(</span><span class="n">bubble_sort</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">t</span><span class="o">*</span><span class="mi">1000</span><span class="si">:</span><span class="s2">&gt;10.4f</span><span class="si">}</span><span class="s2">ms&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

<span class="k">for</span> <span class="n">algo_name</span><span class="p">,</span> <span class="n">algo_func</span> <span class="ow">in</span> <span class="p">[(</span><span class="s2">&quot;Merge Sort&quot;</span><span class="p">,</span> <span class="n">merge_sort</span><span class="p">),</span> 
                              <span class="p">(</span><span class="s2">&quot;Quick Sort&quot;</span><span class="p">,</span> <span class="n">quicksort</span><span class="p">),</span>
                              <span class="p">(</span><span class="s2">&quot;Heap Sort&quot;</span><span class="p">,</span> <span class="n">heapsort</span><span class="p">)]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">algo_name</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">test_sizes</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">measure_time</span><span class="p">(</span><span class="n">algo_func</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">t</span><span class="o">*</span><span class="mi">1000</span><span class="si">:</span><span class="s2">&gt;10.4f</span><span class="si">}</span><span class="s2">ms&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">‚úÖ O(n log n) algorithms scale much better!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="sorting-algorithm-comparison">
<h3>Sorting Algorithm Comparison<a class="headerlink" href="#sorting-algorithm-comparison" title="Link to this heading">#</a></h3>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Algorithm</p></th>
<th class="head"><p>Best</p></th>
<th class="head"><p>Average</p></th>
<th class="head"><p>Worst</p></th>
<th class="head"><p>Space</p></th>
<th class="head"><p>Stable</p></th>
<th class="head"><p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Bubble</p></td>
<td><p>O(n)</p></td>
<td><p>O(n¬≤)</p></td>
<td><p>O(n¬≤)</p></td>
<td><p>O(1)</p></td>
<td><p>Yes</p></td>
<td><p>Simple, slow</p></td>
</tr>
<tr class="row-odd"><td><p>Selection</p></td>
<td><p>O(n¬≤)</p></td>
<td><p>O(n¬≤)</p></td>
<td><p>O(n¬≤)</p></td>
<td><p>O(1)</p></td>
<td><p>No</p></td>
<td><p>Fewer swaps</p></td>
</tr>
<tr class="row-even"><td><p>Insertion</p></td>
<td><p>O(n)</p></td>
<td><p>O(n¬≤)</p></td>
<td><p>O(n¬≤)</p></td>
<td><p>O(1)</p></td>
<td><p>Yes</p></td>
<td><p>Good for small/sorted</p></td>
</tr>
<tr class="row-odd"><td><p>Merge</p></td>
<td><p>O(n log n)</p></td>
<td><p>O(n log n)</p></td>
<td><p>O(n log n)</p></td>
<td><p>O(n)</p></td>
<td><p>Yes</p></td>
<td><p>Guaranteed performance</p></td>
</tr>
<tr class="row-even"><td><p>Quick</p></td>
<td><p>O(n log n)</p></td>
<td><p>O(n log n)</p></td>
<td><p>O(n¬≤)</p></td>
<td><p>O(log n)</p></td>
<td><p>No</p></td>
<td><p>Fast in practice</p></td>
</tr>
<tr class="row-odd"><td><p>Heap</p></td>
<td><p>O(n log n)</p></td>
<td><p>O(n log n)</p></td>
<td><p>O(n log n)</p></td>
<td><p>O(1)</p></td>
<td><p>No</p></td>
<td><p>In-place, guaranteed</p></td>
</tr>
</tbody>
</table>
</div>
</section>
</section>
<hr class="docutils" />
<section id="part-3-searching-algorithms">
<h2>Part 3: Searching Algorithms<a class="headerlink" href="#part-3-searching-algorithms" title="Link to this heading">#</a></h2>
<section id="binary-search-the-o-log-n-workhorse">
<h3>Binary Search - The O(log n) Workhorse<a class="headerlink" href="#binary-search-the-o-log-n-workhorse" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">binary_search_iterative</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Binary Search (Iterative) - O(log n) time, O(1) space</span>
<span class="sd">    </span>
<span class="sd">    Requires: Sorted array</span>
<span class="sd">    Strategy: Repeatedly halve search space</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid</span>
        <span class="k">elif</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Search right half</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Search left half</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Not found</span>

<span class="k">def</span> <span class="nf">binary_search_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Binary Search (Recursive) - O(log n) time, O(log n) space</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mid</span>
    <span class="k">elif</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">binary_search_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">binary_search_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">binary_search_leftmost</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find leftmost occurrence of target.</span>
<span class="sd">    Useful for finding insertion point or first occurrence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span>
    
    <span class="k">return</span> <span class="n">left</span>

<span class="c1"># Test binary search variants</span>
<span class="n">sorted_arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Binary Search Variants:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Array: </span><span class="si">{</span><span class="n">sorted_arr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Find 3 (iterative): index </span><span class="si">{</span><span class="n">binary_search_iterative</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Find 3 (recursive): index </span><span class="si">{</span><span class="n">binary_search_recursive</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Find leftmost 3:    index </span><span class="si">{</span><span class="n">binary_search_leftmost</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Find 10 (not found): </span><span class="si">{</span><span class="n">binary_search_iterative</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="part-4-recursion-divide-and-conquer">
<h2>Part 4: Recursion - Divide and Conquer<a class="headerlink" href="#part-4-recursion-divide-and-conquer" title="Link to this heading">#</a></h2>
<section id="understanding-recursion">
<h3>Understanding Recursion<a class="headerlink" href="#understanding-recursion" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classic recursion example.</span>
<span class="sd">    </span>
<span class="sd">    Base case: n &lt;= 1</span>
<span class="sd">    Recursive case: n * factorial(n-1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fibonacci_recursive</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Naive Fibonacci - O(2‚Åø) - VERY SLOW!</span>
<span class="sd">    </span>
<span class="sd">    Demonstrates exponential time complexity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">fibonacci_recursive</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci_recursive</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fast exponentiation - O(log n)</span>
<span class="sd">    </span>
<span class="sd">    Uses divide and conquer:</span>
<span class="sd">    - If exp is even: base^exp = (base¬≤)^(exp/2)</span>
<span class="sd">    - If exp is odd: base^exp = base * base^(exp-1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">exp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">exp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">base</span>
    
    <span class="k">if</span> <span class="n">exp</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">half</span> <span class="o">=</span> <span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">half</span> <span class="o">*</span> <span class="n">half</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">base</span> <span class="o">*</span> <span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Tower of Hanoi - Classic recursion problem</span>
<span class="k">def</span> <span class="nf">tower_of_hanoi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">auxiliary</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tower of Hanoi - O(2‚Åø) moves</span>
<span class="sd">    </span>
<span class="sd">    Move n disks from source to target using auxiliary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Move disk 1 from </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="c1"># Move n-1 disks to auxiliary</span>
    <span class="n">tower_of_hanoi</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">auxiliary</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    
    <span class="c1"># Move largest disk to target</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Move disk </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Move n-1 disks from auxiliary to target</span>
    <span class="n">tower_of_hanoi</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">auxiliary</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

<span class="c1"># Test recursion</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Recursion Examples:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  5! = </span><span class="si">{</span><span class="n">factorial</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  2^10 = </span><span class="si">{</span><span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Tower of Hanoi (3 disks):&quot;</span><span class="p">)</span>
<span class="n">tower_of_hanoi</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="c1"># Demonstrate exponential growth</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">‚ö†Ô∏è  Fibonacci recursion is SLOW:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]:</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">measure_time</span><span class="p">(</span><span class="n">fibonacci_recursive</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  fib(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">t</span><span class="o">*</span><span class="mi">1000</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  (Notice exponential growth!)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="part-5-dynamic-programming-optimization-through-memoization">
<h2>Part 5: Dynamic Programming - Optimization Through Memoization<a class="headerlink" href="#part-5-dynamic-programming-optimization-through-memoization" title="Link to this heading">#</a></h2>
<section id="memoization-top-down">
<h3>Memoization (Top-Down)<a class="headerlink" href="#memoization-top-down" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fibonacci_memoized</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fibonacci with Memoization - O(n) time, O(n) space</span>
<span class="sd">    </span>
<span class="sd">    Cache results to avoid redundant calculations.</span>
<span class="sd">    Transforms O(2‚Åø) to O(n)!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    
    <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">fibonacci_memoized</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci_memoized</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="c1"># Compare memoized vs naive</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Memoization Performance:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">measure_time</span><span class="p">(</span><span class="n">fibonacci_memoized</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">fibonacci_memoized</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  fib(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">result</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">t</span><span class="o">*</span><span class="mi">1000</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">‚úÖ Memoization makes it FAST!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="tabulation-bottom-up">
<h3>Tabulation (Bottom-Up)<a class="headerlink" href="#tabulation-bottom-up" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fibonacci_tabulation</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fibonacci with Tabulation - O(n) time, O(n) space</span>
<span class="sd">    </span>
<span class="sd">    Build table bottom-up, no recursion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">fibonacci_optimized</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Space-optimized Fibonacci - O(n) time, O(1) space</span>
<span class="sd">    </span>
<span class="sd">    Only keep last two values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    
    <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">,</span> <span class="n">prev</span> <span class="o">+</span> <span class="n">curr</span>
    
    <span class="k">return</span> <span class="n">curr</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Tabulation vs Space-Optimized:&quot;</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Tabulation:      fib(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">fibonacci_tabulation</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Space-optimized: fib(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">fibonacci_optimized</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="classic-dp-problems">
<h3>Classic DP Problems<a class="headerlink" href="#classic-dp-problems" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">longest_common_subsequence</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LCS - O(mn) time and space</span>
<span class="sd">    </span>
<span class="sd">    Find length of longest subsequence common to both strings.</span>
<span class="sd">    </span>
<span class="sd">    DP Formula:</span>
<span class="sd">    - If chars match: dp[i][j] = dp[i-1][j-1] + 1</span>
<span class="sd">    - Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">knapsack_01</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">capacity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    0/1 Knapsack - O(nW) time and space</span>
<span class="sd">    </span>
<span class="sd">    Maximize value within weight capacity.</span>
<span class="sd">    Each item can be taken (1) or not (0).</span>
<span class="sd">    </span>
<span class="sd">    DP Formula:</span>
<span class="sd">    - If weight fits: dp[i][w] = max(value + dp[i-1][w-weight], dp[i-1][w])</span>
<span class="sd">    - Else: dp[i][w] = dp[i-1][w]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">:</span>
                <span class="c1"># Take item or don&#39;t take it</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="n">values</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">w</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]],</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">w</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Can&#39;t take (too heavy)</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">w</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">capacity</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">coin_change</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coin Change - O(amount * len(coins))</span>
<span class="sd">    </span>
<span class="sd">    Find minimum coins to make amount.</span>
<span class="sd">    </span>
<span class="sd">    DP Formula:</span>
<span class="sd">    dp[i] = min(dp[i], dp[i - coin] + 1) for each coin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">coins</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coin</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coin</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># Test DP problems</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dynamic Programming Problems:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="s2">&quot;ABCDGH&quot;</span><span class="p">,</span> <span class="s2">&quot;AEDFHR&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LCS of &#39;</span><span class="si">{</span><span class="n">s1</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">s2</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">longest_common_subsequence</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">8</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Knapsack (weights=</span><span class="si">{</span><span class="n">weights</span><span class="si">}</span><span class="s2">, values=</span><span class="si">{</span><span class="n">values</span><span class="si">}</span><span class="s2">, capacity=</span><span class="si">{</span><span class="n">capacity</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Max value: </span><span class="si">{</span><span class="n">knapsack_01</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">coins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
<span class="n">amount</span> <span class="o">=</span> <span class="mi">63</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Coin Change (coins=</span><span class="si">{</span><span class="n">coins</span><span class="si">}</span><span class="s2">, amount=</span><span class="si">{</span><span class="n">amount</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Min coins: </span><span class="si">{</span><span class="n">coin_change</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span><span class="w"> </span><span class="n">amount</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="part-6-graph-algorithms">
<h2>Part 6: Graph Algorithms<a class="headerlink" href="#part-6-graph-algorithms" title="Link to this heading">#</a></h2>
<section id="graph-representation-and-traversal">
<h3>Graph Representation and Traversal<a class="headerlink" href="#graph-representation-and-traversal" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Graph implementation using adjacency list.</span>
<span class="sd">    </span>
<span class="sd">    Space: O(V + E) where V = vertices, E = edges</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directed</span> <span class="o">=</span> <span class="n">directed</span>
    
    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add edge from u to v.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">directed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Depth-First Search - O(V + E) time, O(V) space</span>
<span class="sd">        </span>
<span class="sd">        Explores as far as possible before backtracking.</span>
<span class="sd">        Uses stack (recursion call stack).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">visited</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">visited</span>
    
    <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Breadth-First Search - O(V + E) time, O(V) space</span>
<span class="sd">        </span>
<span class="sd">        Explores all neighbors before going deeper.</span>
<span class="sd">        Uses queue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>
        
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">vertex</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">visited</span>
    
    <span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dijkstra&#39;s Shortest Path - O((V + E) log V) with heap</span>
<span class="sd">        </span>
<span class="sd">        Finds shortest path from start to all vertices.</span>
<span class="sd">        Works only with non-negative weights.</span>
<span class="sd">        </span>
<span class="sd">        Uses greedy approach + priority queue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">{</span><span class="n">vertex</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">}</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Priority queue: (distance, vertex)</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        
        <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>
            <span class="n">current_dist</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">current</span><span class="p">]:</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">current_dist</span> <span class="o">+</span> <span class="n">weight</span>
                
                <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                    <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">distances</span>
    
    <span class="k">def</span> <span class="nf">topological_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Topological Sort (Kahn&#39;s Algorithm) - O(V + E)</span>
<span class="sd">        </span>
<span class="sd">        Linear ordering of vertices such that for every edge u‚Üív,</span>
<span class="sd">        u comes before v.</span>
<span class="sd">        </span>
<span class="sd">        Only works on Directed Acyclic Graphs (DAGs).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate in-degrees</span>
        <span class="n">in_degree</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">vertex</span><span class="p">]:</span>
                <span class="n">in_degree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Start with vertices having 0 in-degree</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">vertex</span><span class="p">]:</span>
                <span class="n">in_degree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
        
        <span class="c1"># Check for cycle</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># Graph has cycle</span>
        
        <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Test graph algorithms</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Graph Traversal:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DFS from 0: &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">BFS from 0: &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Weighted graph for Dijkstra&#39;s</span>
<span class="n">wg</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dijkstra&#39;s Shortest Path from &#39;A&#39;:&quot;</span><span class="p">)</span>
<span class="n">distances</span> <span class="o">=</span> <span class="n">wg</span><span class="o">.</span><span class="n">dijkstra</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">vertex</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># DAG for topological sort</span>
<span class="n">dag</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Topological Sort:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">dag</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="part-7-space-complexity">
<h2>Part 7: Space Complexity<a class="headerlink" href="#part-7-space-complexity" title="Link to this heading">#</a></h2>
<p>Time isn‚Äôt everything - memory matters too!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">sum_iterative</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum 1 to n iteratively.</span>
<span class="sd">    Time: O(n), Space: O(1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="k">def</span> <span class="nf">sum_recursive</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum 1 to n recursively.</span>
<span class="sd">    Time: O(n), Space: O(n) due to call stack</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">sum_recursive</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sum_formula</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum 1 to n using formula.</span>
<span class="sd">    Time: O(1), Space: O(1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Space Complexity Comparison:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sum 1 to </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Iterative (O(1) space): </span><span class="si">{</span><span class="n">sum_iterative</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Recursive (O(n) space): </span><span class="si">{</span><span class="n">sum_recursive</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Formula   (O(1) space): </span><span class="si">{</span><span class="n">sum_formula</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">üìä Space complexity matters for:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Embedded systems (limited memory)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Recursion depth limits (stack overflow)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Large-scale data processing&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Cloud costs (memory pricing)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<hr class="docutils" />
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">#</a></h2>
<section id="exercise-1-implement-and-analyze-quick-select">
<h3>Exercise 1: Implement and Analyze Quick Select<a class="headerlink" href="#exercise-1-implement-and-analyze-quick-select" title="Link to this heading">#</a></h3>
<p>Implement the QuickSelect algorithm to find the kth smallest element in O(n) average time.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Your code here</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">quickselect</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find kth smallest element (0-indexed).</span>
<span class="sd">    </span>
<span class="sd">    Average: O(n)</span>
<span class="sd">    Worst: O(n¬≤)</span>
<span class="sd">    </span>
<span class="sd">    TODO: Implement using partition similar to quicksort</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c1"># Test</span>
<span class="c1"># arr = [3, 1, 4, 1, 5, 9, 2, 6]</span>
<span class="c1"># print(f&quot;Array: {arr}&quot;)</span>
<span class="c1"># print(f&quot;3rd smallest: {quickselect(arr, 2)}&quot;)</span>
<span class="c1"># print(f&quot;Sorted for verification: {sorted(arr)}&quot;)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="exercise-2-longest-increasing-subsequence">
<h3>Exercise 2: Longest Increasing Subsequence<a class="headerlink" href="#exercise-2-longest-increasing-subsequence" title="Link to this heading">#</a></h3>
<p>Find the length of the longest increasing subsequence using dynamic programming.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Your code here</span>

<span class="k">def</span> <span class="nf">longest_increasing_subsequence</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find length of LIS.</span>
<span class="sd">    </span>
<span class="sd">    Example: [10, 9, 2, 5, 3, 7, 101, 18] ‚Üí 4 ([2, 3, 7, 101])</span>
<span class="sd">    </span>
<span class="sd">    Time: O(n¬≤) with DP, O(n log n) with binary search</span>
<span class="sd">    </span>
<span class="sd">    TODO: Implement using DP</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c1"># Test</span>
<span class="c1"># arr = [10, 9, 2, 5, 3, 7, 101, 18]</span>
<span class="c1"># print(f&quot;Array: {arr}&quot;)</span>
<span class="c1"># print(f&quot;LIS length: {longest_increasing_subsequence(arr)}&quot;)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="exercise-3-detect-cycle-in-graph">
<h3>Exercise 3: Detect Cycle in Graph<a class="headerlink" href="#exercise-3-detect-cycle-in-graph" title="Link to this heading">#</a></h3>
<p>Implement cycle detection in both directed and undirected graphs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Your code here</span>

<span class="k">def</span> <span class="nf">has_cycle_undirected</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detect cycle in undirected graph using DFS.</span>
<span class="sd">    </span>
<span class="sd">    TODO: Implement</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">has_cycle_directed</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detect cycle in directed graph using DFS.</span>
<span class="sd">    </span>
<span class="sd">    Use three colors: white (unvisited), gray (visiting), black (done)</span>
<span class="sd">    </span>
<span class="sd">    TODO: Implement</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c1"># Test</span>
<span class="c1"># Create test graphs and verify</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="exercise-4-implement-a-pathfinding">
<h3>Exercise 4: Implement A* Pathfinding<a class="headerlink" href="#exercise-4-implement-a-pathfinding" title="Link to this heading">#</a></h3>
<p>Implement A* algorithm with Manhattan distance heuristic.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Your code here</span>

<span class="k">def</span> <span class="nf">a_star</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A* pathfinding algorithm.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        grid: 2D array (0 = open, 1 = blocked)</span>
<span class="sd">        start: (row, col)</span>
<span class="sd">        goal: (row, col)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Path as list of (row, col) tuples</span>
<span class="sd">    </span>
<span class="sd">    TODO: Implement using priority queue</span>
<span class="sd">    f(n) = g(n) + h(n)</span>
<span class="sd">    where g(n) = cost so far, h(n) = heuristic estimate to goal</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c1"># Test</span>
<span class="c1"># grid = [</span>
<span class="c1">#     [0, 0, 0, 0, 0],</span>
<span class="c1">#     [0, 1, 1, 0, 0],</span>
<span class="c1">#     [0, 0, 0, 0, 0],</span>
<span class="c1">#     [0, 0, 1, 1, 0],</span>
<span class="c1">#     [0, 0, 0, 0, 0]</span>
<span class="c1"># ]</span>
<span class="c1"># start, goal = (0, 0), (4, 4)</span>
<span class="c1"># path = a_star(grid, start, goal)</span>
<span class="c1"># print(f&quot;Path: {path}&quot;)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="pro-tips">
<h2>Pro Tips<a class="headerlink" href="#pro-tips" title="Link to this heading">#</a></h2>
<section id="algorithm-selection-guide">
<h3>üéØ Algorithm Selection Guide<a class="headerlink" href="#algorithm-selection-guide" title="Link to this heading">#</a></h3>
<p><strong>Sorting</strong>:</p>
<ul class="simple">
<li><p>Small data (&lt; 50): Insertion sort</p></li>
<li><p>Need stability: Merge sort</p></li>
<li><p>Average case speed: Quick sort</p></li>
<li><p>Guaranteed O(n log n): Merge or Heap sort</p></li>
<li><p>In-place required: Quick or Heap sort</p></li>
</ul>
<p><strong>Searching</strong>:</p>
<ul class="simple">
<li><p>Sorted data: Binary search (O(log n))</p></li>
<li><p>Unsorted small data: Linear search</p></li>
<li><p>Unsorted large data: Hash table or sort first</p></li>
</ul>
<p><strong>Graph Algorithms</strong>:</p>
<ul class="simple">
<li><p>Shortest path (unweighted): BFS</p></li>
<li><p>Shortest path (weighted, non-negative): Dijkstra‚Äôs</p></li>
<li><p>Shortest path (negative weights): Bellman-Ford</p></li>
<li><p>All-pairs shortest path: Floyd-Warshall</p></li>
<li><p>Detect cycle: DFS</p></li>
<li><p>Connected components: DFS or Union-Find</p></li>
</ul>
</section>
<section id="common-mistakes">
<h3>‚ö†Ô∏è Common Mistakes<a class="headerlink" href="#common-mistakes" title="Link to this heading">#</a></h3>
<ol class="arabic simple">
<li><p><strong>Not considering space complexity</strong>: O(1) vs O(n) space matters</p></li>
<li><p><strong>Using O(n¬≤) when O(n log n) exists</strong>: Sort before searching</p></li>
<li><p><strong>Forgetting base cases in recursion</strong>: Causes infinite recursion</p></li>
<li><p><strong>Not handling edge cases</strong>: Empty arrays, single elements</p></li>
<li><p><strong>Premature optimization</strong>: Write correct code first, optimize later</p></li>
<li><p><strong>Ignoring integer overflow</strong>: Use appropriate data types</p></li>
<li><p><strong>Not testing with large inputs</strong>: Performance issues only show at scale</p></li>
<li><p><strong>Confusing best/average/worst case</strong>: Know which applies</p></li>
</ol>
</section>
<section id="optimization-strategies">
<h3>üí° Optimization Strategies<a class="headerlink" href="#optimization-strategies" title="Link to this heading">#</a></h3>
<ol class="arabic simple">
<li><p><strong>Hash tables for O(1) lookup</strong>: Trade space for time</p></li>
<li><p><strong>Two pointers</strong>: Avoid nested loops when possible</p></li>
<li><p><strong>Sliding window</strong>: For subarray/substring problems</p></li>
<li><p><strong>Memoization</strong>: Cache expensive recursive calls</p></li>
<li><p><strong>Sort first</strong>: Enables binary search and two pointers</p></li>
<li><p><strong>Use right data structure</strong>: Array, linked list, tree, graph?</p></li>
<li><p><strong>Amortized analysis</strong>: Average over sequence of operations</p></li>
<li><p><strong>Lazy evaluation</strong>: Compute only when needed</p></li>
</ol>
</section>
</section>
<hr class="docutils" />
<section id="key-takeaways">
<h2>Key Takeaways<a class="headerlink" href="#key-takeaways" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p><strong>Big O</strong> describes scalability, not absolute speed</p></li>
<li><p><strong>O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n¬≤) &lt; O(2‚Åø) &lt; O(n!)</strong></p></li>
<li><p><strong>Drop constants and lower-order terms</strong> in Big O</p></li>
<li><p><strong>Sorting</strong>: O(n¬≤) for simple, O(n log n) for efficient</p></li>
<li><p><strong>Searching</strong>: Binary search requires sorted data, gives O(log n)</p></li>
<li><p><strong>Recursion</strong>: Elegant but watch for exponential time and stack space</p></li>
<li><p><strong>Dynamic programming</strong>: Memoization (top-down) or tabulation (bottom-up)</p></li>
<li><p><strong>Graphs</strong>: DFS uses stack, BFS uses queue, both O(V + E)</p></li>
<li><p><strong>Space complexity</strong> matters for embedded systems and recursion limits</p></li>
<li><p><strong>Choose the right algorithm</strong> for your constraints (time, space, stability)</p></li>
</ol>
</section>
<hr class="docutils" />
<section id="next-steps">
<h2>Next Steps<a class="headerlink" href="#next-steps" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p><strong>Practice on LeetCode/HackerRank</strong>: Apply concepts to real problems</p></li>
<li><p><strong>Study advanced topics</strong>: AVL trees, Red-Black trees, Tries</p></li>
<li><p><strong>Learn approximation algorithms</strong>: For NP-hard problems</p></li>
<li><p><strong>Explore parallel algorithms</strong>: Utilize multiple cores</p></li>
<li><p><strong>Read ‚ÄúIntroduction to Algorithms‚Äù</strong>: CLRS textbook</p></li>
<li><p><strong>Implement from scratch</strong>: Best way to truly understand</p></li>
</ol>
<p><strong>Resources</strong>:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.bigocheatsheet.com/">Big O Cheat Sheet</a></p></li>
<li><p><a class="reference external" href="https://visualgo.net/">VisuAlgo</a> - Algorithm visualizations</p></li>
<li><p><a class="reference external" href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition">Introduction to Algorithms (CLRS)</a></p></li>
<li><p><a class="reference external" href="https://www.algorist.com/">Algorithm Design Manual</a></p></li>
</ul>
<hr class="docutils" />
<p><em>Continue to <strong>Deep Learning and Neural Networks</strong> to apply these optimization concepts to ML!</em></p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./hard"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="02_generators_and_iterators.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Hard Lesson 02: Generators and Iterators - Memory-Efficient Data Processing</p>
      </div>
    </a>
    <a class="right-next"
       href="04_deep_learning_and_neural_networks.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Lesson 4: Deep Learning and Neural Networks</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#learning-objectives">Learning Objectives</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#prerequisites">Prerequisites</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#why-algorithms-and-complexity-matter">Why Algorithms and Complexity Matter</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-1-big-o-notation-the-language-of-complexity">Part 1: Big O Notation - The Language of Complexity</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#what-is-big-o">What is Big O?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#common-complexity-classes-best-to-worst">Common Complexity Classes (Best to Worst)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analyzing-code-for-complexity">Analyzing Code for Complexity</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-2-sorting-algorithms-comparison-and-implementation">Part 2: Sorting Algorithms - Comparison and Implementation</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#elementary-sorting-algorithms-o-n2">Elementary Sorting Algorithms (O(n¬≤))</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#advanced-sorting-algorithms-o-n-log-n">Advanced Sorting Algorithms (O(n log n))</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sorting-algorithm-comparison">Sorting Algorithm Comparison</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-3-searching-algorithms">Part 3: Searching Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-search-the-o-log-n-workhorse">Binary Search - The O(log n) Workhorse</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-4-recursion-divide-and-conquer">Part 4: Recursion - Divide and Conquer</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#understanding-recursion">Understanding Recursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-5-dynamic-programming-optimization-through-memoization">Part 5: Dynamic Programming - Optimization Through Memoization</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#memoization-top-down">Memoization (Top-Down)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tabulation-bottom-up">Tabulation (Bottom-Up)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classic-dp-problems">Classic DP Problems</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-6-graph-algorithms">Part 6: Graph Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-representation-and-traversal">Graph Representation and Traversal</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#part-7-space-complexity">Part 7: Space Complexity</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-1-implement-and-analyze-quick-select">Exercise 1: Implement and Analyze Quick Select</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-2-longest-increasing-subsequence">Exercise 2: Longest Increasing Subsequence</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-3-detect-cycle-in-graph">Exercise 3: Detect Cycle in Graph</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-4-implement-a-pathfinding">Exercise 4: Implement A* Pathfinding</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pro-tips">Pro Tips</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algorithm-selection-guide">üéØ Algorithm Selection Guide</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#common-mistakes">‚ö†Ô∏è Common Mistakes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#optimization-strategies">üí° Optimization Strategies</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#key-takeaways">Key Takeaways</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-steps">Next Steps</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Mykolas Perevicius
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      ¬© Copyright 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>